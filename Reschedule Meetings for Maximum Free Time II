/* Tha main approach is that 
step 1 : 
        we are careting a free time array as "free"
step 2:
        for every free index we are computing the "maximum" free time available at its "left" and "right"
step 3:
        now we going to every free time index and just checking
        case 1 :       
                event time of just its left adjacent 
                if event time is <= max(its left free time or right free time)  it means we can move that event to any other place
                        so we will result = max(result, currFree free time + prev free time + event time);
        case 2 :
                just left and right shifting only on that gap
                result = max(result, curr free time + prev free time)
step 4 :
        return result; */


int maxFreeTime(int eventTime, vector<int>& startTime, vector<int>& endTime) {
        int n = startTime.size();

        // free time available
        vector<int> free;
        free.push_back(startTime[0]);
        for(int i=1 ; i<n ; i++){
            free.push_back(startTime[i]-endTime[i-1]);
        }
        free.push_back(eventTime-endTime[n-1]);
        n = free.size();
        vector<int> leftMaxFree(n, 0);
        vector<int> rightMaxFree(n, 0);

        for(int i=1 ; i<n ; i++){
            leftMaxFree[i] = max(leftMaxFree[i-1], free[i-1]);
        }
        for(int i=n-2 ; i>=0 ; i--){
            rightMaxFree[i] = max(rightMaxFree[i+1], free[i+1]);
        }

        int current = 0 ;
        int result = 0;

        for(int i=1; i<n ; i++){
            int currentEventTime = endTime[i-1]-startTime[i-1];

            if(currentEventTime<=max(leftMaxFree[i-1],rightMaxFree[i])){
                result = max(result, free[i-1]+currentEventTime+free[i]);
            }

            result = max(result, free[i-1]+free[i]);
        }

        return result;
    }
